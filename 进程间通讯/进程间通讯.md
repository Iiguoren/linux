## 进程间通讯
管道：内核提供，单工：一端读，一端写；自适应的字同步机制：迁就比较慢的一方
两个单工可以创造一个双端都可读可写的双工管道
匿名管道：只能用于有亲缘关系之间的进程
命名管道：

同一设备进程通讯
跨网络进程间通讯

### pipe()
匿名管道
**作用:**pipe 函数用于创建一个匿名管道，该管道可用于实现单向进程间通信（IPC, Inter-Process Communication）。管道具有读端和写端，数据从写端写入，通过读端读取。
```c
#include <unistd.h>
int pipe(int pipefd[2]);
/*
int pipefd[2]:
一个长度为 2 的整数数组，用于存储管道的文件描述符：
pipefd[0]：管道的读端文件描述符。
pipefd[1]：管道的写端文件描述符。

return:
返回 0：表示管道创建成功。
返回 -1：表示管道创建失败，此时会设置 errno，可通过 perror 或 strerror 获取具体错误信息。
常见错误：
EMFILE：当前进程已达到文件描述符限制。
ENFILE：系统已达到文件描述符限制。
EFAULT：pipefd 指向的地址无效。
*/
```
**实例：创建一个父写子读的管道通讯**
cat 1.mp3 |mpeg123 -
```c
// demo1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(){

    int fd[2];
    pid_t pid;
    char buf[1024];
    if(pipe(fd)){
        
    }
    pid = fork();
    if(pid<0){
        perror("fork()");
        exit(1);
    }
    if(pid==0){// child read
        close(fd[1]);
        int len = read(fd[0], buf, 1024);
        write(1, buf, len);
        close(fd[0]);
        exit(0);
    }
    if(pid>0){ //pareant write
        close(fd[0]);
        write(fd[1], "hello world\n", 12);
        close(fd[1]);
        wait(NULL);
        exit(0);
    }
}
```

### mkfifo()

## IPC
ipc:进程间通信
msgQ:消息队列
semA:信号量数组
shm:共享内存
**key**:确定通讯双方使用的是同一种通讯机制
ftok()
ftok 函数用于生成一个唯一的键值 (key)，该键值常用于System V IPC（如消息队列、共享内存、信号量等）来标识一个资源。
通过 ftok，多个进程可以基于同一个文件路径和项目 ID 生成相同的键值，从而实现对同一 IPC 资源的访问。

### ipcs

## ftok()
```c
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj_id);
```
类似于哈希，pathname是哈希的内容，proj_id是哈希的杂质
主动端：先发包的乙方；被动端：先接受包的一方
msgget
msgop
msgctl

proto.h协议
snder.c发送方
rcver.c接收方
### msgget()
msgget 是一个用于创建或获取消息队列标识符的 System V IPC 函数。消息队列是一种用于进程间通信的机制，可以存储和传递消息。
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
/*
key
说明：用于标识消息队列的键值。
可以使用 ftok 函数生成一个唯一的键。
如果 key 为 IPC_PRIVATE，创建一个新的私有消息队列，仅供创建进程及其子进程使用。

msgflg
说明：控制消息队列的创建或访问方式的标志。
权限标志：使用与文件权限类似的值（如 0666 表示读写权限）。
创建标志：
IPC_CREAT：如果队列不存在，创建一个新的消息队列。
IPC_EXCL：与 IPC_CREAT 一起使用。如果队列已存在，则返回错误。

返回值
成功：返回消息队列的标识符（msqid），用于后续操作（如 msgrcv 和 msgsnd）。
失败：返回 -1，并设置 errno 以指示错误。
*/
```
### msgop()
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);
/*                    
msqid
说明：消息队列标识符，由 msgget 创建或获取。指定从哪个消息队列中接收消息。

msgp
说明：指向接收消息的缓冲区。必须是指向一个包含消息类型和消息正文的结构体的指针。例如：
struct msgbuf {
    long mtype;    // 消息类型
    char mtext[1]; // 消息正文（可变大小）
};
mtype 用于存储消息的类型。
mtext 用于存储消息正文。

msgsz
说明：消息正文的大小（以字节为单位）。不能超过系统定义的最大消息大小。

msgtyp
说明：指定接收消息的类型。
msgtyp > 0：接收第一个 mtype == msgtyp 的消息。
msgtyp == 0：接收队列中的第一个消息。
msgtyp < 0：接收 mtype 小于或等于绝对值 |msgtyp| 的第一个消息。

msgflg
说明：控制接收行为的标志。
IPC_NOWAIT：如果消息队列中没有符合条件的消息，函数立即返回 -1，并设置 errno 为 ENOMSG。
MSG_NOERROR：如果消息正文大小超过 msgsz，则截断消息而不报错。

返回值
成功：返回读取的消息正文大小（以字节为单位）。
失败：返回 -1，并设置 errno 来指示错误。
*/
```
### msgget()
msgget 是一个用于创建或获取消息队列标识符的 System V IPC 函数。消息队列是一种用于进程间通信的机制，可以存储和传递消息。
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgget(key_t key, int msgflg);
/*
key
类型：key_t（通常是一个整数）
说明：用于标识消息队列的键值。
可以使用 ftok 函数生成一个唯一的键。
如果 key 为 IPC_PRIVATE，创建一个新的私有消息队列，仅供创建进程及其子进程使用。

msgflg
类型：int
说明：控制消息队列的创建或访问方式的标志。
权限标志：使用与文件权限类似的值（如 0666 表示读写权限）。
创建标志：
IPC_CREAT：如果队列不存在，创建一个新的消息队列。
IPC_EXCL：与 IPC_CREAT 一起使用。如果队列已存在，则返回错误。

返回值
成功：返回消息队列的标识符（msqid），用于后续操作（如 msgrcv 和 msgsnd）。
失败：返回 -1，并设置 errno 以指示错误。
*/
```
