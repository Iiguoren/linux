## 进程间通讯
管道：内核提供，单工：一端读，一端写；自适应的字同步机制：迁就比较慢的一方
两个单工可以创造一个双端都可读可写的双工管道
匿名管道：只能用于有亲缘关系之间的进程
命名管道：

同一设备进程通讯
跨网络进程间通讯

### pipe()
匿名管道
**作用:**pipe 函数用于创建一个匿名管道，该管道可用于实现单向进程间通信（IPC, Inter-Process Communication）。管道具有读端和写端，数据从写端写入，通过读端读取。
```c
#include <unistd.h>
int pipe(int pipefd[2]);
/*
int pipefd[2]:
一个长度为 2 的整数数组，用于存储管道的文件描述符：
pipefd[0]：管道的读端文件描述符。
pipefd[1]：管道的写端文件描述符。

return:
返回 0：表示管道创建成功。
返回 -1：表示管道创建失败，此时会设置 errno，可通过 perror 或 strerror 获取具体错误信息。
常见错误：
EMFILE：当前进程已达到文件描述符限制。
ENFILE：系统已达到文件描述符限制。
EFAULT：pipefd 指向的地址无效。
*/
```
**实例：创建一个父写子读的管道通讯**
cat 1.mp3 |mpeg123 -
```c
// demo1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(){

    int fd[2];
    pid_t pid;
    char buf[1024];
    if(pipe(fd)){
        
    }
    pid = fork();
    if(pid<0){
        perror("fork()");
        exit(1);
    }
    if(pid==0){// child read
        close(fd[1]);
        int len = read(fd[0], buf, 1024);
        write(1, buf, len);
        close(fd[0]);
        exit(0);
    }
    if(pid>0){ //pareant write
        close(fd[0]);
        write(fd[1], "hello world\n", 12);
        close(fd[1]);
        wait(NULL);
        exit(0);
    }
}
```

### mkfifo()

## IPC
ipc:进程间通信
msgQ:消息队列
semA:信号量数组
shm:共享内存
**key**:确定通讯双方使用的是同一种通讯机制
ftok()
ftok 函数用于生成一个唯一的键值 (key)，该键值常用于System V IPC（如消息队列、共享内存、信号量等）来标识一个资源。
通过 ftok，多个进程可以基于同一个文件路径和项目 ID 生成相同的键值，从而实现对同一 IPC 资源的访问。

### ipcs

## ftok()
```c
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj_id);
```
类似于哈希，pathname是哈希的内容，proj_id是哈希的杂质,这里的pathname文件并没有**实际意义**，只是为了使用唯一的INODE值获得标识
主动端：先发包的乙方；被动端：先接受包的一方
proto.h协议
snder.c发送方
rcver.c接收方
### msgget()
msgget 是一个用于创建或获取消息队列标识符的 System V IPC 函数。消息队列是一种用于进程间通信的机制，可以存储和传递消息。
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
/*
key
说明：用于标识消息队列的键值。
可以使用 ftok 函数生成一个唯一的键。
如果 key 为 IPC_PRIVATE，创建一个新的私有消息队列，仅供创建进程及其子进程使用。

msgflg
说明：控制消息队列的创建或访问方式的标志。
权限标志：使用与文件权限类似的值（如 0666 表示读写权限）。
创建标志：
IPC_CREAT：如果队列不存在，创建一个新的消息队列。需要|一个权限赋予新文件权限
IPC_EXCL：与 IPC_CREAT 一起使用。如果队列已存在，则返回错误。

返回值
成功：返回消息队列的标识符（msqid），用于后续操作（如 msgrcv 和 msgsnd）。
失败：返回 -1，并设置 errno 以指示错误。
*/
```
### msgrcv()
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);
/*                    
msqid
说明：消息队列标识符，由 msgget 创建或获取。指定从哪个消息队列中接收消息。

msgp
说明：指向接收消息的缓冲区。必须是指向一个包含消息类型和消息正文的结构体的指针。例如：
struct msgbuf {
    long mtype;    // 消息类型
    char mtext[1]; // 消息正文（可变大小）
};
mtype 用于存储消息的类型。
mtext 用于存储消息正文。

msgsz
说明：消息正文的大小（以字节为单位）。不能超过系统定义的最大消息大小。

msgtyp
说明：指定接收消息的类型。
msgtyp > 0：接收第一个 mtype == msgtyp 的消息。
msgtyp == 0：接收队列中的第一个消息。
msgtyp < 0：接收 mtype 小于或等于绝对值 |msgtyp| 的第一个消息。

msgflg
说明：控制接收行为的标志。
IPC_NOWAIT：如果消息队列中没有符合条件的消息，函数立即返回 -1，并设置 errno 为 ENOMSG。
MSG_NOERROR：如果消息正文大小超过 msgsz，则截断消息而不报错。

返回值
成功：返回读取的消息正文大小（以字节为单位）。
失败：返回 -1，并设置 errno 来指示错误。
*/
```

### msgsnd()
msgsnd 向指定的消息队列发送消息。消息是一个用户定义的结构，消息队列是一个 FIFO 数据结构，可在进程间实现异步通信。
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
/*
msqid
消息队列标识符，由 msgget 返回，用于标识消息队列。

msgp
指向包含消息内容的用户定义结构的指针。

该结构至少包含一个类型字段，通常定义如下：
struct msgbuf {
    long mtype;      // 消息类型，必须大于 0
    char mtext[];    // 消息正文
};
mtype：消息类型，用于分类检索消息。
mtext：消息正文，大小不固定，由调用者指定。

msgsz
消息正文的大小（mtext 的字节数），不包括 mtype 的大小。

msgflg
控制发送行为的标志，可能的值包括：
0：默认行为。如果消息队列满，则阻塞。
IPC_NOWAIT：非阻塞模式，如果消息队列满，则立即返回错误。

返回值
成功：返回 0。
失败：返回 -1，并设置 errno
*/
```