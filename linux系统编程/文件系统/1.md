# 目录和文件
1.获取文件属性
2.文件访问权限
3.umask
4.文件权限的更改/管理
5.粘住位
6.文件系统:FAT,UFS
7.硬链接，符号链接
8.utime
9、目录的创建和销毁
10、更改当前工作路径
11、分析目录/读取目录内容

## stat()
```c
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>
       int stat(const char *pathname, struct stat *statbuf);
       //获取文件或目录的详细信息，参数：指向文件地址的字符串；一个指向stat结构体的指针，成功返回0失败返回-1
       int fstat(int fd, struct stat *statbuf); //  通过文件描述符指定文件
 struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* inode号，inode是一个文件的唯一标识 */
               mode_t    st_mode;        /*文件类型和权限 */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* 文件拥有者的用户ID */
               gid_t     st_gid;         /* 文件所属组的ID */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* 文件大小（以字节为单位) */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* 文件最后访问时间 */
               struct timespec st_mtim;  /* 文件最后修改时间 */
               struct timespec st_ctim;  /* 文件状态更改时间 */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };
```
实例：设计一个程序用stat()函数获取文件大小
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
static void flen(char * fn){
    struct stat st;
    if(stat(fn, &st)<0){
        perror("stat()");
        exit(0);
    }
    printf("size:%lld byte", (long long)st.st_size);
}                                             
int main(int argc, char** argv){
    if(argc <2){
        fprintf(stderr, "Usage: %s <filename>", argv[0]);
        exit(1);
    }

    flen(argv[1]);
}
```
linux下文件在磁盘中所占用的大小不是看文件字节数的大小，而是block块的大小乘上block(扇区)的数量(st_blocksize * st_blocks);

## 空洞文件
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char **argv){
    int fd;
    fd = open(argv[1], O_WRONLY|O_CREAT, 0666);
    if(fd<0){
        perror("open()");
    }
    lseek(fd, 5LL*1024LL*1024LL*1024LL-1, SEEK_SET);
    write(fd, "", 1);
    close(fd);
    exit(0);
}
```

## 文件属性
`st_mode` 文件属性，类型`mode_t`,16位整型数
一共有dcb-lsp七个文件类型
|代号|文件类型|说明|
|---|-------|--|
|d|目录文件|目录文件包含其他文件和目录的列表，相当于文件夹|
|c|字符设备文件|字符设备文件用于与字符设备（如键盘、串口）进行交互|
|b|块设备文件|块设备文件用于与块设备（如硬盘、光驱）进行交互|
|-|常规文件|文本文件、二进制文件、图像文件|
|l|符号链接|符号链接是指向另一个文件或目录的指针，类似于 Windows 中的快捷方式|
|s|套接字|套接字文件用于进程间的网络通信|
|p|FIFO(管道)|FIFO 文件用于进程间通信，遵循先进先出（FIFO）原则|
linux中下列宏可以判定文件类型：
```c
S_ISREG(m)  is it a regular file?
S_ISDIR(m)  directory?
S_ISCHR(m)  character device?
S_ISBLK(m)  block device?
S_ISFIFO(m) FIFO (named pipe)?
S_ISLNK(m)  symbolic link?  (Not in POSIX.1-1996.)
S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
```
**实例**：
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
void ftype(char *filename){
    struct stat statres;
    if(stat(filename, &statres)<0){
        perror("stat()");
        exit(1);
    }
    if(S_ISREG(statres.st_mode))
        printf("- regular file.\n");
    else if(S_ISDIR(statres.st_mode))
        printf("d directory file.\n");
    else if(S_ISCHR(statres.st_mode))
        printf("c character device.\n");
    else if(S_ISBLK(statres.st_mode))
        printf("b block device.\n");
    else if(S_ISFIFO(statres.st_mode))
        printf("p pipe.\n");
    else if(S_ISLINK(statres.st_mode))
        printf("l link.\n");
    else if(S_ISSOCK(statres.st_mode))
        printf("s socket.\n");
    else
        printf("?");
}
int main(int argc, char **argv){
    if(argv<2){
        fprintf(stderr, "Usage: %s <filename>", argv[0]);
        exit(1);
    }
    ftype(argv[1]);
}
```
```c
上列宏是通过以下&位操作运行：
    S_IFMT     0170000   bit mask for the file type bit field
    S_IFSOCK   0140000   socket
    S_IFLNK    0120000   symbolic link
    S_IFREG    0100000   regular file
    S_IFBLK    0060000   block device
    S_IFDIR    0040000   directory
    S_IFCHR    0020000   character device
    S_IFIFO    0010000   FIFO
```

## 文件权限
umask：作用防止产生权限过松的文件
```c
       #include <sys/stat.h>
       int chmod(const char *pathname, mode_t mode);
       int fchmod(int fd, mode_t mode);
```
粘住位：t位
## 文件系统FAT,UFS
文件或数据的存储和管理
FAT:静态存储的单链表
```c
struct{
    int next[n];
    char data[n][size];
}
```
清理内存软件：创建一个进程不停的吃内存，将物理内存中的数据挤入swap交换分区中。达到一个限度，进程结束，原进程中的数据挤入swap中。
* 换出率： 从物理内存转入swap交换分区
换出是为了将不常用的内存数据放入swap中
* 换入率： 从swap交换分区转入物理内存
换入是为了将原本swap中的拿入内存提高性能
如果换出率和换入率都高，说明系统无法载入所有数据只能不断数据交换

### UFS
(https://blog.csdn.net/m0_63690570/article/details/141331583)

## 链接
文件系统的目录项（directory entry）是一个数据结构，用于建立文件名和文件的 inode 号之间的映射关系。每个目录都是一个文件，它包含了多个目录项，每个目录项包含了一个文件名和一个 inode 号，以及一些其他的元数据信息，如文件类型、权限、所有者、所属组、大小、创建时间、修改时间等。
目录项的结构：
```c
struct dirent
 {
   __ino_t d_ino;		/* inode 号 */
   __off_t d_off;		/* 文件在目录中的偏移量 */
   unsigned short int d_reclen;		/* 目录项长度 */
   unsigned char d_type;			/* 文件类型 */
   char d_name[256];		/* 文件名 We must not include limits.h! */
 };
 // 文件类型参考之前：
 /*
 DT_REG：普通文件
DT_DIR：目录文件
DT_FIFO：命名管道
DT_SOCK：套接字文件
DT_CHR：字符设备文件
DT_BLK：块设备文件
DT_LNK：符号链接文件
*/
```
目录项的作用是将目录中的文件名和文件内容相关联。
## link() unlink()
```c
    #include <unistd.h>
    int link(const char *oldpath, const char *newpath);
    // 创建硬链接，oldpath:指向要链接的现有文件的路径，即原文件。newpath:新硬链接文件的路径，即新文件名。成功返回0，失败返回-1
```
硬链接与目录项是同义词，并且有限制：不能跨分区建立，不能给目录建立；硬链接相当于增添一个目录项，将新文件名关联上同一个文件内容共享同一个inode号。
```c
    #include <unistd.h>
    int unlink(const char *pathname);
//unlink 函数是一个 POSIX 标准库函数，用于删除文件的一个目录项（即删除一个文件名）。如果该文件是该 inode 的最后一个链接，系统将释放文件的 inode 和数据块，从而真正删除文件内容。
```
调用 unlink() 后，文件名从文件系统的目录中删除（**删除目录项**），但文件的 inode 和数据块仍然存在，直到所有引用该文件的文件描述符都被关闭。
```c
    #include <unistd.h>
    int symlink(const char *target, const char *linkpath);
    // 创建符号链接，成功返回0失败返回-1
```
符号链接优点：可以跨分区，可以给目录建立
**open->unlink()->close作用？**
在 Linux 中，open() 函数用来打开文件并返回一个文件描述符（fd）。如果在打开文件之后立即调用 unlink() 来删除文件，但在调用 close() 之前，文件描述符仍然有效，文件内容仍然存在，直到所有指向该文件的描述符被关闭。这个行为与临时文件和常规文件相似，但有一些特殊之处。

与remove()函数的不同？
remove() 是 C 标准库函数，它用于删除指定路径的文件。remove() 函数内部实际上调用了 unlink()，但是它对删除操作进行了封装，使得它也可以用于删除文件和空目录。
remove:
如果删除的是一个目录，目录必须为空。
如果是删除文件，则与 unlink() 的作用相同，删除的是文件的目录项。
## rename()
rename用谁封装？

### utime()

## 目录创建销毁mkdir() rmdir()
## remove(),rmdir()
```c
#include <stdio.h>
int remove(const char *pathname);
/*remove() 是 C 标准库函数，它用于删除指定路径的文件。remove() 函数内部实际上调用了 unlink()，但是它对删除操作进行了封装，使得它也可以用于删除文件和空目录。
remove() 可以删除文件或空目录。
如果删除的是一个目录，目录必须为空。
如果是删除文件，则与 unlink() 的作用相同，删除的是文件的目录项。*/
#include <unistd.h>
int rmdir(const char *pathname);
//如果你需要删除一个空目录，可以使用 rmdir() 函数。rmdir() 只能删除空目录，不能删除包含文件的目录。如果目录非空，rmdir() 会失败。
```
## fseek(),ftell()
```c
       #include <stdio.h>
       int fseek(FILE *stream, long offset, int whence);
       long ftell(FILE *stream);
       // fseek是将文件流指针放到指定位置：offset是偏移值，whence有SEEK_SET, SEEK_CUR, or SEEK_END代表文件头，当前指针，文件尾三个位置;seek成功返回1否则返回0
       // ftell返回文件流当前指针位置
       void rewind(FILE *stream);
        int fflush(FILE *stream); //刷新指定流，如果参数为空刷新所有流
```        
## chdir() fchdir() getcwd() opendir()
```c
#include <unistd.h>
       int chdir(const char *path);
       // 当前工作目录更改为指定目录
       int fchdir(int fd);
       // 将当前工作目录更改为由文件描述符 fd 引用的目录。
       //成功时返回 0，失败时返回 -1，并设置 errno。
#include <unistd.h>
       char *getcwd(char *buf, size_t size);
        // 获取当前工作目录，buf：指向一个字符数组（缓冲区）的指针，size：指定缓冲区的大小，即 buf 的字节数。
        //成功时返回 buf 指向的缓冲区地址，失败时返回 NULL
#include <sys/types.h>
#include <dirent.h>
       DIR *opendir(const char *name);
       DIR *fdopendir(int fd);
       // name:目录的路径名，指定需要打开的目录。
       //成功：返回指向 DIR 类型的指针，该指针用于操作目录。
       //失败：返回 NULL，并设置 errno 表示错误类型。
#include <dirent.h>
int closedir(DIR *dirp);
//关闭一个目录流
```

## glob()
```c
 #include <glob.h>

       int glob(const char *pattern, int flags,
            int (*errfunc) (const char *epath, int eerrno),
                glob_t *pglob);
        //文件名匹配，即模式匹配。它可以根据指定的模式找到符合条件的文件路径或目录名，是实现文件通配符功能的一个标准库函数。
/*pattern：用于匹配文件的模式字符串，支持通配符，如 *、?、[] 等。

            *：匹配任意数量的字符。
            ?：匹配单个字符。
            [abc]：匹配括号内的任意一个字符。
        flags：用于控制匹配行为的标志，常用的标志有：

            GLOB_ERR：遇到无法读取的目录时停止。
            GLOB_MARK：在匹配的目录名后加上斜杠（/）。
            GLOB_NOSORT：不对匹配结果进行排序。
            GLOB_NOCHECK：若没有找到匹配项，则将模式字符串作为匹配结果返回。
            GLOB_TILDE：支持 ~ 表示用户的主目录（POSIX 不标准）。
            GLOB_ONLYDIR：仅匹配目录。
            errfunc：出错时调用的回调函数指针，如果设置为 NULL 则忽略错误。该函数应返回 0 以继续搜索或非 0 以中断搜索。函数的参数：

            epath：出错的路径。
            eerrno：错误代码。
        pglob：指向 glob_t 类型的结构体，用于存储匹配的文件列表。glob_t 定义如下：*/
            typedef struct {
                size_t gl_pathc;    /* 匹配的路径数量 */
                char **gl_pathv;    /* 匹配的路径列表 */
                size_t gl_offs;     /* gl_pathv 的偏移量 */
                } glob_t;
```
```c
#include <glob.h>
#define PAT "/etc/a*.config"

int main(int argc, char **argv){
    int i,err;
    glob_t globres;
    err = glob(PAT, 0, NULL, globres);
    if(err){
        printf("errnum is %d\n", err);
        exit(1);
    }
    for(i=0;i<globres.gl_pathc;i++){
        puts(globres.gl_pathv[i]);
    }
    exita(0);
}
```
当前环境上命令行传通配符传不进去,
```c
#include<stdio.h>
#include<stdlib.h>
#include<dirent.h>
#define "/etc"
int main(int argc, char **argv){
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL){
        perror("opendir()");
        exit(1);
    }
    while((cur = readdir(dp))!=NULL){
        puts(cur->d_name);
    }
    closedir(dp);
    exit(0);
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#define PATHSIZE 1024
static int64_t mydu(const char *path){
    struct stat statres;
    glob_t globres;
    char nextpath[PATHSIZE];
    if(lstat(path, &statres)<0){
        perror("lstat()");
        exit(0);
    }
    if(!S_ISDIR(statres.st_mode))
        return statres.st_block/2;
    strncopy(nextpath,path,PATHSIZE);
    strncat(nextpath,"/*");
    glob(nextpath,0,NULL,&globres);

}

int main (int argc, char **argv){
    DIR *dp;
    dp = opendir();
    if(dp == NULL){
        perror("opendir()");
        exit(1);
    }

    mydu(dp);
    exit(0);
}
```
递归之前可以放到静态区，跨过递归点不行
**实例：实现du查看目录下文件和占用字节**
```c
// du
#include <stdio.h>
#include <stdlib.h>
#include <glob.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>

#define PATHSIZE 1024
int path_noloop(char *path){
    char *pos;
    pos = strrchr(path, '/');
    if(pos == NULL){
        exit(1);
    }
    if(strcmp(pos+1,".")==0||strcmp(pos+1,"..")==0){
        return 0;
    }
    return 1;
}

static int64_t mydu(const char *path){
    static struct stat statres;
    static char nextpath[PATHSIZE];
    glob_t globres;
    // 非目录
    if(lstat(path,&statres)<0){
        perror("lstat()");
        exit(1);
    }

    if(!S_ISDIR(statres.st_mode)){
        fprintf(stdout, "%ld\t%s\n", statres.st_blocks/2, path);
        return statres.st_blocks;
    }

    // 目录
    // 拼接
    strncpy(nextpath, path, PATHSIZE);
    strncat(nextpath, "/*", PATHSIZE);
    if(glob(nextpath, 0, NULL, &globres)<0){
        perror("glob()");
        exit(1);
    }

    strncpy(nextpath, path, PATHSIZE);
    strncat(nextpath, "/.*", PATHSIZE);
    if(glob(nextpath, GLOB_APPEND, NULL, &globres)<0){
        perror("glob()");
        exit(1);
    }

    int sum = statres.st_blocks;
    for(int i = 0; i<globres.gl_pathc; i++){
        if(path_noloop(globres.gl_pathv[i])){
            sum += mydu(globres.gl_pathv[i]);
        }
    }
    globfree(&globres);
    return sum;
}

int main(int argc, char **argv){
    if(argc < 2){
        fprintf(stderr, "Usage:%s:path", argv[0]);
        exit(1);
    }

    printf("%ld\t%s\n", (mydu(argv[1])/2), argv[1]);
    exit(0);
}
```

## 用户信息
* /etc/passwd
* /etc/group
* /etc/shadow
### /etc/passwd 
/etc/passwd 文件是 Linux 系统中存储用户账户信息的核心文件之一。每一行代表一个用户账户，并包含账户的相关信息。
文件内容格式为一行一用户，字段用冒号 : 分隔，每一行包括以下 7 个字段：
```
用户名:密码占位符:用户ID (UID):组ID (GID):用户描述信息:主目录:默认Shell
root:x:0:0:root:/root:/bin/bash
```
有关函数:
```c
#include <sys/types.h>
#include <pwd.h>
    struct passwd *getpwnam(const char *name); 
    // 通过名字返回一个passwd的结构体指针，passwd结构体储存了一个用户的用户信息
    struct passwd *getpwuid(uid_t uid);
    // 通过uid返回一个passwd的结构体指针

    struct passwd {
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
    };
```
**实例：实现通过用户名获取UID功能**
```c
// getuid
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <pwd.h>

int main(int argc, char **argv){
    if(argc <2){
        fprintf(stderr, "Usage: %s <username>\n", argv[0]);
        exit(1);
    }

    struct passwd *userpw;
    userpw = getpwnam(argv[1]);
    /*puts("%d\n", userpw.pw_uid); puts只能输出字符串不能格式化输出*/
    fprintf(stdout, "%d\n", userpw->pw_uid);
    return 0;
}
```
### /etc/group
/etc/group 文件是 Linux 和 Unix 系统中用于存储用户组信息的配置文件。它是系统管理用户组的核心数据之一，与 /etc/passwd 文件协作，提供用户和组的基本信息。
每行包含一个组的信息，字段之间用冒号 : 分隔，格式如下：
```
group_name:password:GID:user_list
组名：组密码：组ID：用户列表
```
linux系统中组密码存放在`/etc/shadow`中，在group中组密码为x隐藏
```c
       #include <sys/types.h>
       #include <grp.h>
       struct group *getgrnam(const char *name);
        // 返回一个记载group信息的结构体指针，接受组的名字
       struct group *getgrgid(gid_t gid);
       // 返回一个记载group信息的结构体指针，接受组的gid
       struct group {
            char   *gr_name;        /* group name */
            char   *gr_passwd;      /* group password */
            gid_t   gr_gid;         /* group ID */
            char  **gr_mem;         /* NULL-terminated array of pointers
                                        to names of group members */
           };
```
**实例：实现通过组名获取组ID功能**
```c
// getgid
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <grp.h>
int main(int argc, char **argv){
    if(argc <2){
        fprintf(stderr, "Usage: %s <username>\n", argv[0]);
        exit(1);
    }

    struct group *grpmsg;
    grpmsg = getgrnam(argv[1]);
    /*puts("%d\n", userpw.pw_uid); puts只能输出字符串不能格式化输出*/
    fprintf(stdout, "%d\n", grpmsg->gr_gid);
    return 0;
}
```
### /etc/shadow
/etc/shadow 是 Linux 和 Unix 系统中用于存储用户密码和相关信息的配置文件。它增强了系统的安全性，通过限制对密码数据的访问来保护用户的登录信息。
每行表示一个用户的密码：
`username:password:last_changed:min_age:max_age:warn:inactive:expire:reserved`
```
liguoren:$5$AJbMxprNmek$ckgGJu567p.5lWxAUyv8TbTPdtuPNCgrN5TG20mr7u.:19822:0:99999:7:::
加密后的密码哈希值，由三个部分组成：
$5$：表示使用 SHA-256 加密算法。
AJbMxprNmek：Salt（盐值），用来增加密码哈希的复杂性，防止彩虹表攻击。
ckgGJu567p.5lWxAUyv8TbTPdtuPNCgrN5TG20mr7u.：实际的 哈希值。
如果密码字段是 ! 或 *，表示账户被锁定。
```
* 为什么需要Salt:
   如果一个用户有两个一样的密码，那么这两个的哈希值就会相同；就可以使用第一个的哈希值破解第二个密码。
   Salt是一种随机生成的数据，系统为每个用户生成独一的Salt然后进行哈希计算：`Hash=HashFunction(Salt+Password)`，
   生成哈希值。
   **这样就可以防止同样的密码有同样的哈希值**。
```c
#include <shadow.h>
struct spwd *getspnam(const char *name);
// 通过用户name得到一个spwd的结构体
struct spwd {
    char *sp_namp;     /* Login name */
    char *sp_pwdp;     /* Encrypted password */
    long  sp_lstchg;   /* Date of last change
                            (measured in days since
                            1970-01-01 00:00:00 +0000 (UTC)) */
    long  sp_min;      /* Min # of days between changes */
    long  sp_max;      /* Max # of days between changes */
    long  sp_warn;     /* # of days before password expires
                            to warn user to change it */
    long  sp_inact;    /* # of days after password expires
                            until account is disabled */
    long  sp_expire;   /* Date when account expires
                            (measured in days since
                            1970-01-01 00:00:00 +0000 (UTC)) */
    unsigned long sp_flag;  /* Reserved */
};
```

```c
#include <crypt.h>
char * crypt(const char *phrase, const char *setting);
char * crypt_r(const char *phrase, const char *setting,
         struct crypt_data *data);
/*phrase：
    用户输入的明文密码（或其他字符串）。
    长度不应超过系统允许的最大值（一般为 255 字节）。
setting：
    包含密码哈希算法和盐值信息的字符串。常见格式：
    $id$salt$，其中：
    $id$ 指定哈希算法：
    $1$：MD5
    $5$：SHA-256
    $6$：SHA-512
    salt 是哈希使用的盐值，通常为 8-16 个字符的随机字符串。*/
```
这两个函数是用于密码加密的库函数，它们主要用于生成哈希密码，常见于基于 Linux/Unix 的系统。它们通常结合 passwd 和 /etc/shadow 等文件的处理。
在输入密码的时候如何做到**隐藏输入**：
```c
#include <unistd.h>
char *getpass(const char *prompt);
//prompt:要显示在终端的提示信息，例如 "Enter password: ".如果传入 NULL，则不会显示任何提示信息。
//从标准输入读取信息，返回读取的字符串
```
**实例：实现一个验证用户密码的功能**
```c
// chekpas
#include <crypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <shadow.h>
#include <string.h>
int main(int argc, char **argv){
    if(argc <2){
        fprintf(stderr, "Usage: %s <password>\n", argv[0]);
        exit(1);
    }
    struct spwd *spusr;
    char *password;
    char *hashpw;
    password = getpass("Input your word:");
    spusr = getspnam(argv[1]);
    hashpw = crypt(password, spusr->sp_pwdp); //完整的加密密码函数只会取$id$salt$部分
    if(strcmp(hashpw, spusr->sp_pwdp)==0)
        puts("OK\n");
    else
        puts("false\n");
}
```