# 目录和文件
1.获取文件属性
2.文件访问权限
3.umask
4.文件权限的更改/管理
5.粘住位
6.文件系统:FAT,UFS
7.硬链接，符号链接
8.utime
9、目录的创建和销毁
10、更改当前工作路径
11、分析目录/读取目录内容

## stat()
```c
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>
       int stat(const char *pathname, struct stat *statbuf);
       //获取文件或目录的详细信息，参数：指向文件地址的字符串；一个指向stat结构体的指针，成功返回0失败返回-1
       int fstat(int fd, struct stat *statbuf); //  通过文件描述符指定文件
 struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* inode号，inode是一个文件的唯一标识 */
               mode_t    st_mode;        /*文件类型和权限 */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* 文件拥有者的用户ID */
               gid_t     st_gid;         /* 文件所属组的ID */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* 文件大小（以字节为单位) */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* 文件最后访问时间 */
               struct timespec st_mtim;  /* 文件最后修改时间 */
               struct timespec st_ctim;  /* 文件状态更改时间 */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };
```
实例：设计一个程序用stat()函数获取文件大小
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
static void flen(char * fn){
    struct stat st;
    if(stat(fn, &st)<0){
        perror("stat()");
        exit(0);
    }
    printf("size:%lld byte", (long long)st.st_size);
}
int main(int argc, char** argv){
    if(argc <2){
        fprintf(stderr, "Usage: %s <filename>", argv[0]);
        exit(1);
    }

    flen(argv[1]);
}
```
linux下文件在磁盘中所占用的大小不是看文件字节数的大小，而是block块的大小乘上block(扇区)的数量(st_blocksize * st_blocks);

## 空洞文件
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char **argv){
    int fd;
    fd = open(argv[1], O_WRONLY|O_CREAT, 0666);
    if(fd<0){
        perror("open()");
    }
    lseek(fd, 5LL*1024LL*1024LL*1024LL-1, SEEK_SET);
    write(fd, "", 1);
    close(fd);
    exit(0);
}
```