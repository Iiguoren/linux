信号
信号的概念
signal()
信号的不可靠
可重入函数
信号的响应过程
常用函数：
    kill
    raise
    alarm
    pause
    abort
    system
    sleep    
信号集
信号屏蔽字/pending集处理
sigsuspend
sigaction
sititimer
实时信号

线程
## 异步时间的处理：查询法，通知法

## 信号
信号是软件中断，信号的响应依赖于终端
中止+core是什么：


信号会打断阻塞的系统调用
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#define BUFSIZE 1024
int main(int argc, char **argv){
    int fds, fdd;
    char buf[BUFSIZE];
    int len,ret,pos;
    if(argc<3){
        fprintf(stderr, "Usage:%s <src_name> <dest_name>\n", argv[1]);
        exit(1);
    }
    fds = open(argv[1], O_RDONLY);
    do{
        if(fds <0){
            if(errno != EINTR)
                perror("open()");
                exit(1);
        }
    }while(fds<0); //判断是否信号导致的open堵塞打断

    fdd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0666);
    do{
        if(fdd <0){
            if(errno != EINTR)
                perror("open()");
                exit(1);
        }
    }while(fdd<0);
    while(1){
        len = read(fds, buf, BUFSIZE);
        if(len < 0){
            if(errno == EINTR)
                continue;
            perror("read()");
            break;
        }
        if(len == 0)
            break;
        pos = 0;
        while(len>0){
            ret = write(fdd, buf + pos, len);
            if(ret<0){
                if(errno == EINTR)
                    continue;
                perror("write()");
                exit(1);
            }
            pos += ret;
            len -= ret;
        }
    }
    close(fdd);
    close(fds);
    exit(0);
}
```
```c
#include <signal.h>

void (*signal(int signum, void (*handler)(int)))(int);
```
**实例：忽略ctrl c信号/信号的回调函数**
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
int main(){
   int i;
   signal(SIGINT, SIG_IGN);
   /*signal(SIGINT, int_handler);*/
   for(i = 0;i<10;i++){
   	printf("*\n");
   	sleep(1);
   }
   return 0;
}
```
在信号的回调函数中，如果快速触发回调就会终端sleep的堵塞造成下一个printf的立刻执行