## 文件属性
`st_mode` 文件属性，类型`mode_t`,16位整型数
一共有dcb-lsp七个文件类型
|代号|文件类型|说明|
|---|-------|--|
|d|目录文件|目录文件包含其他文件和目录的列表，相当于文件夹|
|c|字符设备文件|字符设备文件用于与字符设备（如键盘、串口）进行交互|
|b|块设备文件|块设备文件用于与块设备（如硬盘、光驱）进行交互|
|-|常规文件|文本文件、二进制文件、图像文件|
|l|符号链接|符号链接是指向另一个文件或目录的指针，类似于 Windows 中的快捷方式|
|s|套接字|套接字文件用于进程间的网络通信|
|p|FIFO(管道)|FIFO 文件用于进程间通信，遵循先进先出（FIFO）原则|
linux中下列宏可以判定文件类型：
```c
S_ISREG(m)  is it a regular file?
S_ISDIR(m)  directory?
S_ISCHR(m)  character device?
S_ISBLK(m)  block device?
S_ISFIFO(m) FIFO (named pipe)?
S_ISLNK(m)  symbolic link?  (Not in POSIX.1-1996.)
S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
```
**实例**：
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
void ftype(char *filename){
    struct stat statres;
    if(stat(filename, &statres)<0){
        perror("stat()");
        exit(1);
    }
    if(S_ISREG(statres.st_mode))
        printf("- regular file.\n");
    else if(S_ISDIR(statres.st_mode))
        printf("d directory file.\n");
    else if(S_ISCHR(statres.st_mode))
        printf("c character device.\n");
    else if(S_ISBLK(statres.st_mode))
        printf("b block device.\n");
    else if(S_ISFIFO(statres.st_mode))
        printf("p pipe.\n");
    else if(S_ISLINK(statres.st_mode))
        printf("l link.\n");
    else if(S_ISSOCK(statres.st_mode))
        printf("s socket.\n");
    else
        printf("?");
}
int main(int argc, char **argv){
    if(argv<2){
        fprintf(stderr, "Usage: %s <filename>", argv[0]);
        exit(1);
    }
    ftype(argv[1]);
}
```
```c
上列宏是通过以下&位操作运行：
    S_IFMT     0170000   bit mask for the file type bit field
    S_IFSOCK   0140000   socket
    S_IFLNK    0120000   symbolic link
    S_IFREG    0100000   regular file
    S_IFBLK    0060000   block device
    S_IFDIR    0040000   directory
    S_IFCHR    0020000   character device
    S_IFIFO    0010000   FIFO
```

## 文件权限
umask：作用防止产生权限过松的文件
```c
       #include <sys/stat.h>
       int chmod(const char *pathname, mode_t mode);
       int fchmod(int fd, mode_t mode);
```
粘住位：t位
## 文件系统FAT,UFS
文件或数据的存储和管理
FAT:静态存储的单链表
```c
struct{
    int next[n];
    char data[n][size];
}
```
清理内存软件：创建一个进程不停的吃内存，将物理内存中的数据挤入swap交换分区中。达到一个限度，进程结束，原进程中的数据挤入swap中。
* 换出率： 从物理内存转入swap交换分区
换出是为了将不常用的内存数据放入swap中
* 换入率： 从swap交换分区转入物理内存
换入是为了将原本swap中的拿入内存提高性能
如果换出率和换入率都高，说明系统无法载入所有数据只能不断数据交换

### UFS
(https://blog.csdn.net/m0_63690570/article/details/141331583)

## 链接
文件系统的目录项（directory entry）是一个数据结构，用于建立文件名和文件的 inode 号之间的映射关系。每个目录都是一个文件，它包含了多个目录项，每个目录项包含了一个文件名和一个 inode 号，以及一些其他的元数据信息，如文件类型、权限、所有者、所属组、大小、创建时间、修改时间等。
目录项的结构：
```c
struct dirent
 {
   __ino_t d_ino;		/* inode 号 */
   __off_t d_off;		/* 文件在目录中的偏移量 */
   unsigned short int d_reclen;		/* 目录项长度 */
   unsigned char d_type;			/* 文件类型 */
   char d_name[256];		/* 文件名 We must not include limits.h! */
 };
 // 文件类型参考之前：
 /*
 DT_REG：普通文件
DT_DIR：目录文件
DT_FIFO：命名管道
DT_SOCK：套接字文件
DT_CHR：字符设备文件
DT_BLK：块设备文件
DT_LNK：符号链接文件
*/
```
目录项的作用是将目录中的文件名和文件内容相关联。
## link() unlink()
```c
    #include <unistd.h>
    int link(const char *oldpath, const char *newpath);
    // 创建硬链接，oldpath:指向要链接的现有文件的路径，即原文件。newpath:新硬链接文件的路径，即新文件名。成功返回0，失败返回-1
```
硬链接与目录项是同义词，并且有限制：不能跨分区建立，不能给目录建立；硬链接相当于增添一个目录项，将新文件名关联上同一个文件内容共享同一个inode号。
```c
    #include <unistd.h>
    int unlink(const char *pathname);
//unlink 函数是一个 POSIX 标准库函数，用于删除文件的一个目录项（即删除一个文件名）。如果该文件是该 inode 的最后一个链接，系统将释放文件的 inode 和数据块，从而真正删除文件内容。
```
调用 unlink() 后，文件名从文件系统的目录中删除（**删除目录项**），但文件的 inode 和数据块仍然存在，直到所有引用该文件的文件描述符都被关闭。
```c
    #include <unistd.h>
    int symlink(const char *target, const char *linkpath);
    // 创建符号链接，成功返回0失败返回-1
```
符号链接优点：可以跨分区，可以给目录建立
**open->unlink()->close作用？**
在 Linux 中，open() 函数用来打开文件并返回一个文件描述符（fd）。如果在打开文件之后立即调用 unlink() 来删除文件，但在调用 close() 之前，文件描述符仍然有效，文件内容仍然存在，直到所有指向该文件的描述符被关闭。这个行为与临时文件和常规文件相似，但有一些特殊之处。

与remove()函数的不同？
remove() 是 C 标准库函数，它用于删除指定路径的文件。remove() 函数内部实际上调用了 unlink()，但是它对删除操作进行了封装，使得它也可以用于删除文件和空目录。
remove:
如果删除的是一个目录，目录必须为空。
如果是删除文件，则与 unlink() 的作用相同，删除的是文件的目录项。
## rename()
rename用谁封装？

### utime()

## 目录创建销毁mkdir() rmdir()
## remove(),rmdir()
```c
#include <stdio.h>
int remove(const char *pathname);
/*remove() 是 C 标准库函数，它用于删除指定路径的文件。remove() 函数内部实际上调用了 unlink()，但是它对删除操作进行了封装，使得它也可以用于删除文件和空目录。
remove() 可以删除文件或空目录。
如果删除的是一个目录，目录必须为空。
如果是删除文件，则与 unlink() 的作用相同，删除的是文件的目录项。*/
#include <unistd.h>
int rmdir(const char *pathname);
//如果你需要删除一个空目录，可以使用 rmdir() 函数。rmdir() 只能删除空目录，不能删除包含文件的目录。如果目录非空，rmdir() 会失败。
```
## fseek(),ftell()
```c
       #include <stdio.h>
       int fseek(FILE *stream, long offset, int whence);
       long ftell(FILE *stream);
       // fseek是将文件流指针放到指定位置：offset是偏移值，whence有SEEK_SET, SEEK_CUR, or SEEK_END代表文件头，当前指针，文件尾三个位置;seek成功返回1否则返回0
       // ftell返回文件流当前指针位置
       void rewind(FILE *stream);
        int fflush(FILE *stream); //刷新指定流，如果参数为空刷新所有流
```        
## chdir() fchdir() getcwd()