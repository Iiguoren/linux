1. 进程标识符pid
    类型:pid_t
    命令：ps
    进程号顺次向下使用与fd不同
    getpid()函数
    getppid()函数
2. * 进程的产生fork(),vfork()
    fork后父子进程的区别(duplicate):pid,ppid不同，未决信号锁和文件锁不继承，资源利用量归零
    fflush()的重要性
    init进程：1号进程，所有进程的祖先进程
3. * 进程的消亡/释放资源
4. * esec()函数族
5. 用户权限与组权限
6. system()
7. 进程会计
8. 进程时间
9.  守护进程，系统日志的书写
    
```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
//fork 是一个系统调用，用于创建一个新的进程（子进程）。它是 UNIX 系统中实现多任务的核心机制之一。
/*在父进程中：返回子进程的进程 ID（正整数）。
在子进程中：返回 0。
如果出错：<返回 -1，并设置 errno（如系统资源不足导致无法创建子进程）。*/
```
```c
//proexample.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main(){
    pid_t pid;

    printf("%d Processing\n", getpid());
    fflush(NULL); /*!!!!!复制进程会把缓冲区复制过去*/
    pid = fork();
    if(pid < 0){
        perror("fork()");
        exit(1);
    }
    else if (pid == 0){
        printf("%d:child is processing \n",getpid());
    }
    else{
        printf("%d:parent is processing \n",getpid());
    }
    
    printf("%d Ending\n", getpid());

    exit(0);
}
```
调度器的调度策略来决定哪个进程先运行
ps axf
**实例：素数**
```c
// primer0.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#define LEFT 30000000
#define RIGHT 30000200
int main(){
    int i,j;
    for(i = LEFT; i<RIGHT; i++){
        for(j = 2; j<i/2; j++){
            if(i % j == 0)
                break;
        }
        if(j == i/2)
        	printf("%d is a primer.\n", i);
    }
    exit(0);
}
```
```c
//primer1.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#define LEFT 30000000
#define RIGHT 30000200
int main(){
    pid_t pid;
    int i,j;
    for(i = LEFT; i<RIGHT; i++){
        pid = fork();
        if(pid < 0 ){
            perror("fork()");
            exit(1);
        }
        if(pid == 0){
            for(j = 2; j<i/2; j++){
                if(i % j == 0)
                    break;
            }
            if(j == i/2){
                printf("%d is a primer.\n", i);}
            exit(0);
        	}
        }
    printf("main over.\n");
    exit(0);
}
```
linux:
`time ./primer1 > /dev/null`程序重定向到/dev/null 终端输出time
```
liguoren@ubuntu:~/linux/process$ time ./primer0 > /dev/null

real	0m0.420s
user	0m0.419s
sys	0m0.000s
liguoren@ubuntu:~/linux/process$ time ./primer1 > /dev/null

real	0m0.012s
user	0m0.000s
sys	0m0.012s
```
### 父子进程之间关系

```c
如果在primer1中的子进程添加sleep():
if(pid == 0){
            for(j = 2; j<i/2; j++){
                if(i % j == 0)
                    break;
            }
            if(j == i/2){
                printf("%d is a primer.\n", i);}
            sleep(1000);
            exit(0);
        	}
使用ps axf查看进程情况，201个子进程如下：
  18699 pts/4    S      0:00  \_ ./primer1
  18700 pts/4    S      0:00  \_ ./primer1
  18701 pts/4    S      0:00  \_ ./primer1
  18702 pts/4    S      0:00  \_ ./primer1
  18703 pts/4    S      0:00  \_ ./primer1
  18704 pts/4    S      0:00  \_ ./primer1
```
S状态表示子进程为sleep状态，父进程./primer1头部没有空格表示父进程已经转为init进程，等sleep结束回收进程;

如果在primer1中的**主进程**添加sleep():
```c
if(pid == 0){
            for(j = 2; j<i/2; j++){
                if(i % j == 0)
                    break;
            }
            if(j == i/2){
                printf("%d is a primer.\n", i);}
            sleep(1000);
            exit(0);
        	}
使用ps axf查看进程情况，201个子进程如下：
  18877 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
  18878 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
  18879 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
  18880 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
  18881 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
  18882 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
  18883 pts/4    Z+     0:00  |           \_ [primer1] <defunct>
```
Z+表示当前为僵尸进程，子进程已经结束但并未被父进程回收，因为在上述primer1中并未写回收功能，只能等父进程结束转交给init进程回收而父进程处于sleep状态无法回收，子进程成为僵尸进程
**思考题：大量僵尸进程存在的坏处:**
1.占用pid资源

### fork与vfork
fork函数使用写时拷贝技术当父进程和子进程只读同一份资源，不做改变。如果写同一个资源，谁写入谁拷贝一份到新的内存写入
vfork创建的子进程与父进程共享同一个地址空间，这意味着子进程可以直接访问父进程的变量、函数和堆栈等。由于父进程被挂起，直到子进程调用 exec 函数或 _exit 函数终止，父进程在子进程运行期间是阻塞的。
由于子进程与父进程共享同一份地址空间，因此在子进程中修改父进程的变量和数据可能会导致**不可预期的行为**，因此要小心使用。一般来说，vfork 主要用于创建一个新进程，并在该进程中立即调用 exec 函数来加载一个新程序。这样可以避免复制父进程的大型地址空间，提高创建子进程的效率。**vfork是为了解决写时拷贝之前的fork函数问题，因此vfork函数现在已经没有必要使用**

## 进程消亡与释放资源
```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *wstatus);
/*
等待任意一个子进程结束。
返回已结束的子进程的 PID。
如果子进程在此之前已经终止，wait 会立即返回，而不会阻塞父进程。等待任意一个子进程结束。
返回已结束的子进程的 PID。
如果子进程在此之前已经终止，wait 会立即返回，而不会阻塞父进程。
成功：返回结束的子进程的 PID。
失败：返回 -1，同时设置 errno。*/
wstatus 一个整型变量的地址值
pid_t waitpid(pid_t pid, int *wstatus, int options);
/*等待指定的子进程（通过 PID 指定）。可以通过选项控制是否阻塞父进程。
pid：
>0：等待指定 PID 的子进程。
0：等待与当前进程属于同一个进程组的任意子进程。
-1：与 wait 的行为一致，等待任意子进程。
<-1：等待指定进程组 ID 的子进程。
options：
0：默认行为，与 wait 相同，阻塞直到子进程退出。
WNOHANG：非阻塞模式，如果没有子进程退出，立即返回 0。
WUNTRACED：等待因信号停止的子进程。
WCONTINUED：等待因 SIGCONT 继续运行的子进程。
返回值：
成功：返回结束的子进程的 PID。
子进程未结束：返回 0（当 options 设置为 WNOHANG 时）。
失败：返回 -1，并设置 errno。*/
```
如果wait参数是`NULL`系统不会保存子进程的退出状态。但仍会等待子进程结束，并返回其 PID。**这种用法适用于只关心子进程的终止，而不需要获取其退出状态的场景。**
**实例：带回收功能的多进程素数**
```c
//primer2.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#define LEFT 30000000
#define RIGHT 30000200
int main(){
    pid_t pid;
    int i,j;
    for(i = LEFT; i<RIGHT; i++){
        pid = fork();
        if(pid < 0 ){
            perror("fork()");
            exit(1);
        }
        if(pid == 0){
            for(j = 2; j<i/2; j++){
                if(i % j == 0)
                    break;
            }
            if(j == i/2){
                printf("%d is a primer.\n", i);}
            exit(0);
        	}
        }
    for(i = LEFT; i<RIGHT; i++){
        wait(NULL);
    }
    printf("main over.\n");
    exit(0);
}
```
增加上述之后main程序会在回收所有子进程后退出

### 交叉分配法
交叉分配法是N个进程轮流调用
**实例交叉分配法实现**
```c
//primer3.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#define LEFT 30000000
#define RIGHT 30000200
#define N 3
int main(){
    pid_t pid;
    int i,j,n;
    for(n = 0; n<N; n++){
        pid = fork();
        if(pid <0){
            perror("fork()");
            exit(1);
        }
        if(pid == 0){
            for(i = LEFT+n; i<RIGHT; i+=N){           
                for(j = 2; j<i/2; j++){
                    if(i % j == 0)
                        break;
                }
                if(j == i/2){
                    printf("%d is a primer.\n", i);}
                }
                exit(0);
            }
        }

    for(n = 0; n<N; n++){
        wait(NULL);
    }
    printf("main over.\n");
    exit(0);
}
```

## exec
exec函数族的功能是用新的process替换现在的process
```c
#include <unistd.h>

extern char **environ; // 环境变量

int execl(const char *pathname, const char *arg, ...
                /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                /* (char  *) NULL */);
int execle(const char *pathname, const char *arg, ...
                /*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                char *const envp[]);

```
**实例：few实现**
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
int main(){
    pid_t pid;
    printf("begin\n");
    pid = fork();
     if(pid <0){
        perror("fork()");
        exit(1);
     }
    if(pid == 0){
        execl("/home/liguoren/linux/process/primer0", "primer0", NULL);
    }
    wait(NULL);
    printf("end\n");
    return 0;
}
```

## shell
shell:while(等待命令输入：)->接受并创建子进程执行命令->堵塞等待子进程结束->while(等待命令输入：)