## 竞争现象
设想一个情况：
    **实现**：20个线程中打开同一个文件，对文件+1，关闭；达到+1的多线程实现。
    **情况**：
    标准库都是线程安全的，因此**在多个线程中可以共享同一个文件流指针，从而共同访问同一个文件。**
    ```c
        fopen(fp, "r+");
        fgets(linebuf, BUFSIZE, fp);
        fprintf(fp, "%d", atoi(linebuf)+1);
        fclose();
    ```
    此时由于文件流指针是共享的，会导致1->12>123>1234的情况。
    因此必须每个线程对流做重置。
    ```c
        fopen(fp, "r+");
        fseek(fp, 0, SEEK_SET);
        fgets(linebuf, BUFSIZE, fp);
        fprintf(fp, "%d", atoi(linebuf)+1);
        fclose();
    ```
    **竞争**：在fopen里为1时，多个线程同时拿到了1的数，进行+然后写入，等于多个线程只做了一个+1的情况。

## 互斥量
    临界区：只能一个线程执行的代码段；
    在临界区加入互斥量这样一次只能一个线程访问，其余线程等待该线程释放锁。
    ### PTHREAD_MUTEX_INITIALIZER
    PTHREAD_MUTEX_INITIALIZER 是用于静态初始化 POSIX互斥量（pthread mutex） 的宏，定义在 <pthread.h> 头文件中。它是一个**常量表达式**，允许在声明互斥量时直接进行初始化，而无需显式调用 pthread_mutex_init()。
    ```c
        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
        ...
        pthread_mutex_lock(&mux);
        fopen(fp, "r+");
        fseek(fp, 0, SEEK_SET);
        fgets(linebuf, BUFSIZE, fp);
        fprintf(fp, "%d", atoi(linebuf)+1);
        fclose();
        pthread_mutex_unlock(&mux);
    ```
