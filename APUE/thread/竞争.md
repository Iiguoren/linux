## 竞争现象
设想一个情况：
    **实现**：20个线程中打开同一个文件，对文件+1，关闭；达到+1的多线程实现。
    **情况**：
    标准库都是线程安全的，因此**在多个线程中可以共享同一个文件流指针，从而共同访问同一个文件。**
    ```c
        fopen(fp, "r+");
        fgets(linebuf, BUFSIZE, fp);
        fprintf(fp, "%d", atoi(linebuf)+1);
        fclose();
    ```
    此时由于文件流指针是共享的，会导致1->12>123>1234的情况。
    因此必须每个线程对流做重置。
    ```c
        fopen(fp, "r+");
        fseek(fp, 0, SEEK_SET);
        fgets(linebuf, BUFSIZE, fp);
        fprintf(fp, "%d", atoi(linebuf)+1);
        fclose();
    ```
    **竞争**：在fopen里为1时，多个线程同时拿到了1的数，进行+然后写入，等于多个线程只做了一个+1的情况。

## 互斥量
    临界区：只能一个线程执行的代码段；
    在临界区加入互斥量这样一次只能一个线程访问，其余线程等待该线程释放锁。
    ### PTHREAD_MUTEX_INITIALIZER
    PTHREAD_MUTEX_INITIALIZER 是用于静态初始化 POSIX互斥量（pthread mutex） 的宏，定义在 <pthread.h> 头文件中。它是一个**常量表达式**，允许在声明互斥量时直接进行初始化，而无需显式调用 pthread_mutex_init()。
    ```c
        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
        ...
        pthread_mutex_lock(&mux);
        fopen(fp, "r+");
        fseek(fp, 0, SEEK_SET);
        fgets(linebuf, BUFSIZE, fp);
        fprintf(fp, "%d", atoi(linebuf)+1);
        fclose();
        pthread_mutex_unlock(&mux);
    ```
**这个模式非常重要**
同步：
sigaction控制线程退出
在线程handle中加入互斥锁来顺序解锁
```c
//abcd.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>
#include <wait.h>
#include <string.h>
#include <signal.h>
#define N 4
static volatile int running = 1; // 全局标志变量，用于控制线程退出
static pthread_mutex_t arr[N];
void sigalrm_handler(int signum) {
    running = 0; // 设置标志变量，通知线程退出
}
static void *handle(void *p){
    int n = (int)p;
    int c = 'a'+n;
    while(1){
        pthread_mutex_lock(&arr[n]);//锁住资源
        write(1, &c, 1);
        pthread_mutex_unlock(&arr[(n+1)%N]);//解锁下一个线程
    }
    return NULL;
 }
 int main(){
    pthread_t Ptid[N];
    void *ptr =NULL;
    struct sigaction sa;
    sa.sa_handler = sigalrm_handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    for(int i = 0; i< N; i++){
        
        pthread_mutex_init(&arr[i],NULL);// 传递初始属性
        pthread_mutex_lock(&arr[i]);//main线程锁住，先建立线程
        int err = pthread_create(&Ptid[i], NULL, handle, (void *)i); //void *接受一切指针
        if(err<0){
            fprintf(stderr, "pthread_create():%s\n", strerror(err));
            exit(1);
        }
    }
    alarm(4);
    pthread_mutex_unlock(&arr[0]);//建立完解开第一个锁
    for(int i = 0; i< N; i++){
        pthread_join(&Ptid[i], NULL);
        pthread_mutex_destroy(&arr[i]);
    }
    exit(0);
 }
```

